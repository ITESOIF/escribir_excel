---
title: "Notas 2 - Parte 1 - Ejemplo Administración Pasiva de Capital"
output:
  html_document: default
  html_notebook: default
  pdf_document: default
---

Notas de repaso sobre 

- Fecha: 23-Agosto-2017, ITESO
- Objetivo: Construir un portafolio de inversión con 3 activos, utilizando la Teoría Moderna de Portafolios
- Situación de aprendizaje: Diferenciar entre portafolio de inversión y estrategia de trading
- Resultado esperado: Datos y gráfica de evolución de capital

<br>

### Inicialización, descarga de precios.

Se comienza con especificar algunas funciones complementarias como limpiar el environment (Seguramente correrás este código más de una vez), la forma de expresar una cifra (Sin notación científica), cargar las librerías, y los datos necesarias para descargar los precios de *QUANDL*. 

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE, warning=FALSE, message=FALSE}
# Remover todos los objetos del "Environment"
rm(list = ls())

# los 0s aceptados antes de expresas una cifra en notación científica
options("scipen"=100, "digits"=4)

### Cargas librerías a utilizar
suppressMessages(library(plotly)) # Graficas interactivas
suppressMessages(library(Quandl)) # Descargar Precios
suppressMessages(library(PortfolioAnalytics)) # Teoría Moderna de Portafolios
suppressMessages(library(ROI)) # Optimizacion para portafolio
suppressMessages(library(knitr))  # Opciones de documentación + código
suppressMessages(library(kableExtra)) # Tablas en HTML
suppressMessages(library(xlsx))

options(knitr.table.format = "html") 

# Cargar el token de QUANDL
Quandl.api_key("dN9QssXxzTxndaqKUQ_i")

# Funcion para descagar precios
Bajar_Precios <- function(Columns, Tickers, Fecha_In, Fecha_Fn) {
  
  # Funcion para descargar N cantidad de activos desde QUANDL
  # -- Dependencias: QUANDL
  # -- Columns : columnas a incluir : character : c("date", "adj_close", ... )
  # -- Tickers : Tickers o claves de pizarra de los activos : character : "TSLA"
  # -- Fecha_In : Fecha Inicial : character : "2017-01-02"
  # -- Fecha_Fn : Fecha Final : character : "2017-08-02"
  
  # Peticion para descargar precios
  Datos <- Quandl.datatable(code = "WIKI/PRICES", qopts.columns=Columns,
                            ticker=Tickers,
                            date.gte=Fecha_In, date.lte=Fecha_Fn)
  return(Datos)
}

# Tickers de acciones contenidas en ETF-IAK
tk <- as.data.frame(read.xlsx(file = "~/GitHub/escribir_excel/iShares-US-Insurance-ETF_fund.xlsx",
                                 sheetName = "Holdings",
                                 colIndex=1,
                                 startRow=10,
                                 endRow=73,header = FALSE))

tk <- c(as.character(tk[,1]))
cs <- c("date", "adj_close")

# Fecha inicial y fecha final
fs <- c("2016-01-20", "2018-01-20")

# Descargar Precios
Datos <- list()

for(i in 1:length(tk)) {
  Datos[[i]] <- Bajar_Precios(Columns=cs, Ticker=tk[i], Fecha_In=fs[1], Fecha_Fn=fs[2])
}

names(Datos) <- tk

Capital_Inicial <- 10000
```

### Eliminar activos sin precios

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE,warning=FALSE, message=FALSE}

longitudes <- c()

for(i in 1:length(Datos)){
  longitudes[i] <- length(Datos[[i]]$date)
}

maximo <- max(longitudes)
completos <- which(longitudes == maximo)

DatosN <- Datos[completos]

```


<br>

### Calcular los rendimientos logarítmicos.

Utilizaremos la propiedad de los logarítmos para calcular los rendimientos.

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE, warning=FALSE, message=FALSE}
for(i in 1:length(completos))
  DatosN[[i]]$adj_close_r <- c(0, diff(log(DatosN[[i]]$adj_close)))
```

<br>

### Transformación a XTS
Las funciones a utilizar de la librería *PortfolioAnalytics* pedirán que los datos de entrada sean del tipo *XTS*.

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE}

# Vector para almacenar columnas de interes
columnas <- c()
nuevos <- c()

# Función para repetir una función por cada columna del data.frame
Rends <- do.call(cbind, DatosN)

# Crear vector con nombres de columnas de interes = "nombredeactivo.adj_close_r"
for(i in 1:length(tk)){
  nuevos[i] <- paste(tk[i], ".adj_close_r", sep="")
}

# Extraer 1 renglon para obtener los nombres de las columnas
nombres <- colnames(Rends[1,(names(Rends) %in% nuevos)])

# Elejir una columna Date y las demás columnas de rendimientos
RendsN <- Rends[,(names(Rends) %in% nuevos)]
row.names(RendsN) <- Rends[,1]

# Reasignar nombres al data.frame
nombres <- as.character(tk[completos])
colnames(RendsN) <- nombres

# Eliminar primer renglon de rendimiento 0
RendsN <- RendsN[-1,]

# Convertir a xts
RendsN <- xts(RendsN, order.by = as.POSIXct(row.names(RendsN)))
names(RendsN) <- tk[completos]

```

<br>

### Crear un objeto tipo *portfolio*

Para hacerlo simplemente crea un Objeto tipo "Portfolio", especificando el nombre de los activos que contendrá.
```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE}
Port1 <- portfolio.spec(assets=nombres)
```

<br>

### Especificar restricciones del portafolio

En este caso especificaremos dos restricciones: Restriccion 1: La suma de todos los pesos debe de ser 1, es decir, Invertir el 100% del capital en el portafolio. 

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE}
Port1 <- add.constraint(portfolio=Port1,
                        type="full_investment")
LimSup <- c()
LimInf <- c()

for(i in 1:length(nombres)){
  LimInf[i] <- 0.01 #Peso individual minimo
  LimSup[i] <- 0.8 #Peso individual maximo
}

# Restriccion 2: Limites superior e inferior para el valor de los pesos individuales
 Port1 <- add.constraint(portfolio=Port1,
                         type="box", 
                         min=LimInf,
                         max=LimSup)
```

<br>

### Especificar los objetivos del portafolio
En este caso especificamos el objetivo de encontrar el portafolio con máximo rendimiento.


```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE}
# Restricción 3: Objetivo de rendimiento
Port1 <- add.objective(portfolio=Port1, type="return", name="mean")
```

<br>

### Optimizar portafolio

Existen distintos métodos de optimización ofrecidos por éste paquete, utilzaremos el más simple, generar números aleatorios según el criterio interno y la búsqueda para cuando se alcance el criterio de paro, que es alcanzar un objetivo previamente declarado, en este caso el de un rendimiento esperado máximo despues de *n* iteraciones de portafolios aleatorios.

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=FALSE, message=FALSE, error=FALSE, warning=FALSE}
Rendimientos <- as.data.frame(RendsN)

# Optimizacion de portafolio con RANDOM
Port1 <- optimize.portfolio(R=Rendimientos, portfolio=Port1, optimize_method = "random",
                            search_size=5000, trace=TRUE)
```

<br>

### Visualizar portafolios

Vamos a construir las funciones con las cuales almacenaremos los datos que nos interesan de los portafolio encontrados, que son: Los pesos, los rendimientos esperados (Medias), el riesgo (Varianzas), así como distinguir cuales de estos portafolios se considera están dentro o en una vecindad de la frontera eficiente.

```{r,eval=TRUE, include=TRUE, echo=TRUE, fig.width=9.5}

Portafolios <- vector("list", length = length(Port1$random_portfolio_objective_results))

for(i in 1:length(Port1$random_portfolio_objective_results)) {
  
  Portafolios[[i]]$Pesos  <- Port1$random_portfolio_objective_results[[i]]$weights
  Portafolios[[i]]$Medias <-  Port1$random_portfolio_objective_results[[i]]$objective_measures$mean
  Portafolios[[i]]$Vars   <- var.portfolio(R = Port1$R, weights = Portafolios[[i]]$Pesos)
  names(Portafolios[[i]]$Medias) <- NULL
}

df_Portafolios <- data.frame(matrix(nrow=length(Port1$random_portfolio_objective_results),
                                    ncol=3, data = 0))
colnames(df_Portafolios) <- c("Rend","Var","Clase")

for(i in 1:length(Port1$random_portfolio_objective_results)) {
  
  df_Portafolios$Rend[i] <- round(Portafolios[[i]]$Medias*252,4)
  df_Portafolios$Var[i]  <- round(sqrt(Portafolios[[i]]$Vars)*sqrt(252),4)
  df_Portafolios$Clase[i] <- "No-Frontera"
  
  for(k in 1:length(tk)) {
    df_Portafolios[i,paste("Peso_", tk[k],sep="")] <- Portafolios[[i]]$Pesos[k]

    df_Portafolios[i,paste("Titulos_ini_", tk[k],sep="")] <-
      (Capital_Inicial*Portafolios[[i]]$Pesos[k])%/%Datos[[k]]$adj_close[1]
  }
  
  
}

# Titulos <- (Capital_Inicial*Pesos[1,1])%/%Datos[[1]]$adj_close[1]


Plot_portafolios <- plot_ly(x=df_Portafolios$Var, y=df_Portafolios$Rend, type='scatter', mode='markers',
                            name = "Portafolios", marker = list(color="grey", size=7), hoverinfo='text', 
                    text = ~paste('Rendimiento: ', paste(df_Portafolios$Rend*100, "%") ,
                                  '<br> Riesgo: ', paste(df_Portafolios$Var*100, "%") )) %>% 
                    layout(title = "Portafolios (Markowitz)",
                           xaxis = list(title = "Riesgo (Desviación Estándar Anualizada)",
                                        showgrid = F),
                           yaxis = list(title = "Valor Esperado (Rendimiento Anualizado)"),
                           legend = list(orientation = 'h', y = -0.25))
Plot_portafolios
```

<br>

### Gráfica histórica de portafolios

Seguramente habrá un gran número de portafolios generados, para cada uno se puede calcular, por ejemplo, el valor de su postura inicial, el valor final y obtener el rendimiento final después del periodo. También, por ejemplo, se puede calcular para cada periodo (dato) el valor del portafolio, asumiendo que los pesos permanecen constantes en el tiempo, y con eso graficar el histórico de ese valo de portafolio para cada tiempo. Pero la cuestión es, qué portafolios estaría interesante de graficar. Bueno, te propongo los 3 "Más básicos": El del máximo rendimiento, el de la mínima varianza y el del máximo sharpe ratio. 

```{r,eval=TRUE, include=TRUE, prompt=FALSE, message=FALSE, error=FALSE, warning=FALSE}
# Portafolio con máximo rendimiento esperado
Port_1 <- df_Portafolios[which.max(df_Portafolios$Rend),]

# Portafolio con mínima varianza
Port_2 <- df_Portafolios[which.min(df_Portafolios$Var),]

# Tasa libre de riesgo
rf <- 0.025
# Rendimiento de portafolio
rp <- df_Portafolios$Rend
# Varianza de portafolio
sp <- df_Portafolios$Var
# Indice de sharpe
sharpe <- (rp-rf)/sp

# Portafolio con máximo Sharpe ratio 
Port_3 <- df_Portafolios[which.max(sharpe),]

Ports <- cbind(rbind(Port_1, Port_2, Port_3),
               "Portafolio" = c("Máximo Rendimiento","Mínima Varianza","Máximo Sharpe Ratio"))
```

```{r,eval=TRUE, include=TRUE, echo=TRUE, prompt=TRUE}
kable(Ports) %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed", "responsive"))
```

<br>

### Distinguiendo los nuevos portafolios

Si quisieramos volver a graficar la nube de dispersión de puntos y localizar los portafolios elegidos en el código anterior, pregunta: ¿ Todos los portafolios estarían sobre, o al menos cerca, de la frontera eficiente ? , veamos.

```{r,eval=TRUE, include=TRUE, prompt=FALSE, message=FALSE, error=FALSE, fig.width=9.5, fig.height=6}
Plot_portafolios <- plot_ly(x=df_Portafolios$Var, y=df_Portafolios$Rend, type='scatter', mode='markers',
                            name = "Portafolios", marker = list(color="grey", size=7), hoverinfo='text', 
                    text = ~paste('Rendimiento: ', paste(df_Portafolios$Rend*100, "%") ,
                                  '<br> Riesgo: ', paste(df_Portafolios$Var*100, "%") )) %>% 
                    layout(title = "Portafolios (Markowitz)",
                           xaxis = list(title = "Riesgo (Desviación Estándar Anualizada)",
                                        showgrid = F),
                           yaxis = list(title = "Valor Esperado (Rendimiento Anualizado)"),
                           legend = list(orientation = 'h', y = -0.25)) %>%
                    add_trace(x = ~Ports$Var[1], y = ~Ports$Rend[1], name = Ports$Portafolio[1],
                              mode = 'marker', marker = list(color="red", size=10)) %>%
                    add_trace(x = ~Ports$Var[2], y = ~Ports$Rend[2], name = Ports$Portafolio[2],
                              mode = 'marker', marker = list(color="blue", size=10)) %>%
                    add_trace(x = ~Ports$Var[3], y = ~Ports$Rend[3], name = Ports$Portafolio[3],
                              mode = 'marker', marker = list(color="orange", size=10))
Plot_portafolios
```

<br>

### La evolución del valor en los portafolios: El cáculo

Podemos entonces, para cada portafolio (en este ejemplo analizamos 3), calcular la evolución histórica de su balance. 

```{r,eval=TRUE, include=TRUE, echo=TRUE}

# Pesos y titulos iniciales, de todos los activos, para los 3 portafolios
Pesos_Titulos <- Ports[,-c(1,2,3)]

# Encontrar las columnas cuyo nombre contenga "Titulos_ini", con esas encontraremos más fácil los títulos
# por portafolio por activo
Ind <- grep(pattern = "Titulos_ini",x = colnames(Pesos_Titulos))
Historicos_Ports <- data.frame("Date" = Datos[[1]]$date)

# Crear data frame que contendrá los datos finales de cada estrategia
for(i in 1:length(Ports[,1])) {
  Historicos_Ports[[paste("Portafolio_",i,sep="")]] <- 
    (Datos[[1]]$adj_close*Pesos_Titulos[i,Ind[1]]  + 
     Datos[[2]]$adj_close*Pesos_Titulos[i,Ind[2]] +
     Datos[[3]]$adj_close*Pesos_Titulos[i,Ind[3]])
}

```

<br>

### La evolución del valor en los portafolios: La gráfica

También podemos visualizar el comportamiento histórico.

```{r,eval=TRUE, include=TRUE, prompt=FALSE, message=FALSE, error=FALSE, fig.width=9.5, fig.height=6}

plot_ly(Historicos_Ports) %>%
 add_trace(x = ~Date, y = ~round(Portafolio_1,2), type = 'scatter', mode = 'lines', name = 'Máximo Rendimiento',
            line = list(color = 'red'), hoverinfo = "text", text = ~paste('Port_1',round(Portafolio_1,2))) %>%
  add_trace(x = ~Date, y = ~round(Portafolio_2,2), type = 'scatter', mode = 'lines', name = 'Mínima Varianza',
            line = list(color = 'blue'), hoverinfo = "text", text = ~paste('Port_2',round(Portafolio_2,2)))  %>%
  add_trace(x = ~Date, y = ~round(Portafolio_3,2), type = 'scatter', mode = 'lines', name = 'Máximo Sharpe Ratio',
            line = list(color = 'orange'), hoverinfo = "text", text = ~paste('Port_3',round(Portafolio_3,2)))%>% 
  layout(title = "3 Portafolios distintos objetivos",
         xaxis = list(title = "Fechas", showgrid = T),
         yaxis = list(title = "Balance"), 
         legend = list(orientation = 'h', y = -0.25, x = 0.5))

```
